<!doctype html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Block Fighter | MJ Kang</title>
        <meta name="description" content="PVP pong" />
        <link rel="canonical" href="https://pong-wars.koenvangilst.nl/" />
        <link rel="author" href="https://koenvangilst.nl" />
        <meta name="theme-color" content="#172B36" />
        <meta name="creator" content="Koen van Gilst" />
        <script src="script.js"></script>
        <link rel="stylesheet" href="style.css" />
    </head>

    <body>
        <div id="container">
            <div id="hud">
                <span id="dayInfo"></span>
                <span id="timer"></span>
                <span id="nightInfo"></span>
            </div>
            <canvas id="pongCanvas" width="600" height="600"></canvas>
            <div id="overlay"></div>
            <div id="overlayLeft" class="side-overlay hidden">3</div>
            <div id="overlayRight" class="side-overlay hidden">3</div>
            <p id="made">
                made by MJ | Inspired by
                <a href="https://github.com/vnglst/pong-wars">Pong Wars</a>
            </p>
        </div>
    </body>

    <script>
        // Source palette: https://twitter.com/AlexCristache/status/1738610343499157872
        // Idea for Pong wars: https://twitter.com/nicolasdnl/status/1749715070928433161

        const colorPalette = {
            ArcticPowder: "#F1F6F4",
            MysticMint: "#D9E8E3",
            Forsythia: "#FFC801",
            DeepSaffron: "#FF9932",
            NocturnalExpedition: "#114C5A",
            OceanicNoir: "#172B36",
        };

        const canvas = document.getElementById("pongCanvas");
        const ctx = canvas.getContext("2d");

        const dayInfo = document.getElementById("dayInfo");
        const nightInfo = document.getElementById("nightInfo");
        const timerEl = document.getElementById("timer");
        const overlay = document.getElementById("overlay");
        const overlayLeft = document.getElementById("overlayLeft");
        const overlayRight = document.getElementById("overlayRight");

        const DAY_COLOR = colorPalette.MysticMint;
        const DAY_BALL_COLOR = colorPalette.NocturnalExpedition;
        const NIGHT_COLOR = colorPalette.NocturnalExpedition;
        const NIGHT_BALL_COLOR = colorPalette.MysticMint;
        const SQUARE_SIZE = 25;
        const MIN_SPEED = 4;
        const MAX_SPEED = 12;
        const BASE_SPEED = 4; // launch speed
        const PADDLE_WIDTH = 12;
        const PADDLE_HEIGHT = 100;
        const PADDLE_SPEED = 8;
        const FRAME_RATE = 100;
        const COUNTDOWN_MS = 3000;
        const GAME_TIME_MS = 60_000;
        const WIN_PERCENT = 0.6;

        const numSquaresX = canvas.width / SQUARE_SIZE;
        const numSquaresY = canvas.height / SQUARE_SIZE;
        const totalSquares = numSquaresX * numSquaresY;

        let dayScore = 0;
        let nightScore = 0;

        const squares = [];
        resetGrid();

        const GAME_STATE = {
            IDLE: "idle",
            PLAYING: "playing",
            GAME_OVER: "game_over",
        };

        let state = GAME_STATE.IDLE;
        let remainingTimeMs = GAME_TIME_MS;
        let lastTimestamp = performance.now();

        const balls = [
            {
                x: canvas.width / 2,
                y: canvas.height / 2,
                dx: 0,
                dy: 0,
                owner: "DAY",
                radius: SQUARE_SIZE / 2,
                cooldownMs: 0,
                timeSinceLaunchMs: 0,
            },
            {
                x: canvas.width / 2,
                y: canvas.height / 2,
                dx: 0,
                dy: 0,
                owner: "NIGHT",
                radius: SQUARE_SIZE / 2,
                cooldownMs: 0,
                timeSinceLaunchMs: 0,
            },
        ];

        const paddles = {
            day: {
                x: 10,
                y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                width: PADDLE_WIDTH,
                height: PADDLE_HEIGHT,
                color: DAY_BALL_COLOR,
                owner: "DAY",
            },
            night: {
                x: canvas.width - PADDLE_WIDTH - 10,
                y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                width: PADDLE_WIDTH,
                height: PADDLE_HEIGHT,
                color: NIGHT_BALL_COLOR,
                owner: "NIGHT",
            },
        };

        const keysDown = new Set();

        document.addEventListener("keydown", (e) => {
            if (["w", "s", "ArrowUp", "ArrowDown"].includes(e.key)) {
                keysDown.add(e.key);
            }
            if (e.key === " ") {
                handleSpace();
            }
        });

        document.addEventListener("keyup", (e) => {
            keysDown.delete(e.key);
        });

        function handleGlobalPointerStart() {
            if (state === GAME_STATE.IDLE || state === GAME_STATE.GAME_OVER) {
                handleSpace();
            }
        }

        // Start on any tap/click
        document.addEventListener("pointerdown", handleGlobalPointerStart, {
            passive: false,
        });

        // Touch controls: left half moves Day paddle, right half moves Night paddle
        function screenToCanvasY(clientY) {
            const rect = canvas.getBoundingClientRect();
            const y = ((clientY - rect.top) / rect.height) * canvas.height;
            return y;
        }

        function handleTouch(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            for (const touch of e.touches) {
                const isLeft = touch.clientX < rect.left + rect.width / 2;
                const target = isLeft ? paddles.day : paddles.night;
                const y = screenToCanvasY(touch.clientY) - target.height / 2;
                target.y = Math.max(
                    0,
                    Math.min(canvas.height - target.height, y),
                );
            }
        }

        canvas.addEventListener("touchstart", handleTouch, { passive: false });
        canvas.addEventListener("touchmove", handleTouch, { passive: false });

        function handleSpace() {
            if (state === GAME_STATE.IDLE || state === GAME_STATE.GAME_OVER) {
                startNewGame();
            }
        }

        function startNewGame() {
            resetGrid();
            paddles.day.y = canvas.height / 2 - PADDLE_HEIGHT / 2;
            paddles.night.y = canvas.height / 2 - PADDLE_HEIGHT / 2;
            balls.forEach((b, idx) => {
                b.x = canvas.width / 2;
                b.y = canvas.height / 2;
                b.dx = 0;
                b.dy = 0;
                b.owner = idx === 0 ? "DAY" : "NIGHT";
                b.cooldownMs = 0;
            });
            remainingTimeMs = GAME_TIME_MS;
            state = GAME_STATE.PLAYING;
            resetAllBalls();
            overlay.classList.add("hidden");
            startBtn.classList.add("hidden");
        }

        function resetGrid() {
            for (let i = 0; i < numSquaresX; i++) {
                squares[i] = [];
                for (let j = 0; j < numSquaresY; j++) {
                    squares[i][j] =
                        i < numSquaresX / 2 ? DAY_COLOR : NIGHT_COLOR;
                }
            }
        }

        function launchBall(targetBall, direction) {
            // direction: +1 to the right (toward Night), -1 to the left (toward Day)
            const angle = (Math.random() - 0.5) * Math.PI; // -90..+90 degrees around forward
            const speed = BASE_SPEED;
            targetBall.dx = Math.cos(angle) * speed * direction;
            targetBall.dy = Math.sin(angle) * speed;
            targetBall.cooldownMs = 0;
            targetBall.timeSinceLaunchMs = 0;
            clampBallSpeed(targetBall);
        }

        function resetBall(
            targetBall,
            direction,
            owner,
            startX,
            paused = false,
        ) {
            targetBall.x = startX;
            targetBall.y = canvas.height / 2;
            targetBall.owner = owner;
            if (paused) {
                targetBall.dx = 0;
                targetBall.dy = 0;
                targetBall.cooldownMs = COUNTDOWN_MS;
                targetBall.timeSinceLaunchMs = 0;
            } else {
                launchBall(targetBall, direction);
            }
        }

        function resetAllBalls() {
            const dayStartX = canvas.width * 0.25;
            const nightStartX = canvas.width * 0.75;
            resetBall(balls[0], 1, "DAY", dayStartX);
            resetBall(balls[1], -1, "NIGHT", nightStartX);
        }

        function drawBall(b) {
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2, false);
            const baseColor =
                b.owner === "DAY" ? DAY_BALL_COLOR : NIGHT_BALL_COLOR;
            ctx.fillStyle = getPoweredColor(baseColor, b);
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddles() {
            Object.values(paddles).forEach((paddle) => {
                ctx.fillStyle = paddle.color;
                ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            });
        }

        function drawSquares() {
            dayScore = 0;
            nightScore = 0;

            for (let i = 0; i < numSquaresX; i++) {
                for (let j = 0; j < numSquaresY; j++) {
                    ctx.fillStyle = squares[i][j];
                    ctx.fillRect(
                        i * SQUARE_SIZE,
                        j * SQUARE_SIZE,
                        SQUARE_SIZE,
                        SQUARE_SIZE,
                    );

                    if (squares[i][j] === DAY_COLOR) dayScore++;
                    if (squares[i][j] === NIGHT_COLOR) nightScore++;
                }
            }
        }

        function checkSquareCollisionAndPaint(b) {
            const ownerColor = b.owner === "DAY" ? DAY_COLOR : NIGHT_COLOR;
            const opponentColor = b.owner === "DAY" ? NIGHT_COLOR : DAY_COLOR;
            let bounced = false;
            const power = getBallPower(b);

            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                const checkX = b.x + Math.cos(angle) * b.radius;
                const checkY = b.y + Math.sin(angle) * b.radius;

                const i = Math.floor(checkX / SQUARE_SIZE);
                const j = Math.floor(checkY / SQUARE_SIZE);

                if (i >= 0 && i < numSquaresX && j >= 0 && j < numSquaresY) {
                    if (squares[i][j] === opponentColor) {
                        squares[i][j] = ownerColor;
                        // Break extra squares in travel direction based on power
                        const stepI = Math.sign(b.dx);
                        const stepJ = Math.sign(b.dy);
                        let ii = i;
                        let jj = j;
                        for (let p = 1; p < power; p++) {
                            ii += stepI;
                            jj += stepJ;
                            if (
                                ii < 0 ||
                                ii >= numSquaresX ||
                                jj < 0 ||
                                jj >= numSquaresY
                            ) {
                                break;
                            }
                            if (squares[ii][jj] === opponentColor) {
                                squares[ii][jj] = ownerColor;
                            }
                        }
                        if (
                            Math.abs(Math.cos(angle)) >
                            Math.abs(Math.sin(angle))
                        ) {
                            b.dx = -b.dx;
                        } else {
                            b.dy = -b.dy;
                            // If vertical flip is tiny near edges, add jitter to escape
                            if (Math.abs(b.dy) < MIN_SPEED / 2) {
                                b.dy =
                                    (b.dy >= 0 ? 1 : -1) *
                                    (MIN_SPEED / 2 + 0.5);
                            }
                        }
                        bounced = true;
                    }
                }
            }

            if (bounced) clampBallSpeed(b);
        }

        function checkWallCollision(b) {
            if (b.y - b.radius <= 0 || b.y + b.radius >= canvas.height) {
                b.dy = -b.dy;
                // Nudge away from wall to avoid sticking
                if (b.y - b.radius <= 0) b.y = b.radius + 1;
                if (b.y + b.radius >= canvas.height)
                    b.y = canvas.height - b.radius - 1;
                // Ensure some vertical component after wall bounce
                if (Math.abs(b.dy) < MIN_SPEED / 2) {
                    b.dy = (b.dy >= 0 ? 1 : -1) * (MIN_SPEED / 2);
                }
                clampBallSpeed(b);
            }
        }

        function checkPaddleCollision(b) {
            checkCircleRectCollision(b, paddles.day, 1);
            checkCircleRectCollision(b, paddles.night, -1);
        }

        function checkCircleRectCollision(ball, paddle, normalDirection) {
            // normalDirection: +1 for right-facing normal (left paddle), -1 for left-facing normal (right paddle)
            const nearestX = clamp(ball.x, paddle.x, paddle.x + paddle.width);
            const nearestY = clamp(ball.y, paddle.y, paddle.y + paddle.height);
            const dx = ball.x - nearestX;
            const dy = ball.y - nearestY;
            const distSq = dx * dx + dy * dy;

            if (distSq <= ball.radius * ball.radius) {
                // Determine collision normal
                let nx = 0;
                let ny = 0;
                const overlapX1 = Math.abs(ball.x - (paddle.x - ball.radius));
                const overlapX2 = Math.abs(
                    ball.x - (paddle.x + paddle.width + ball.radius),
                );
                const overlapY1 = Math.abs(ball.y - (paddle.y - ball.radius));
                const overlapY2 = Math.abs(
                    ball.y - (paddle.y + paddle.height + ball.radius),
                );

                // Prefer horizontal normal when approaching from sides
                if (
                    overlapX1 < overlapY1 &&
                    overlapX1 < overlapY2 &&
                    normalDirection === 1
                ) {
                    nx = 1;
                } else if (
                    overlapX2 < overlapY1 &&
                    overlapX2 < overlapY2 &&
                    normalDirection === -1
                ) {
                    nx = -1;
                } else {
                    // Top or bottom
                    ny = dy > 0 ? 1 : -1;
                }

                if (nx !== 0) {
                    ball.dx = Math.abs(ball.dx) * nx;
                }
                if (ny !== 0) {
                    ball.dy = Math.abs(ball.dy) * ny;
                }

                addDeflection(ball, paddle);
                ball.owner = paddle.owner;
                // Push ball slightly out of paddle to prevent sticking
                ball.x += nx * 2;
                ball.y += ny * 2;
                clampBallSpeed(ball);
            }
        }

        function clamp(value, min, max) {
            return Math.min(max, Math.max(min, value));
        }

        function addDeflection(b, paddle) {
            const paddleCenter = paddle.y + paddle.height / 2;
            const distanceFromCenter = b.y - paddleCenter;
            b.dy += distanceFromCenter * 0.08;
        }

        function clampBallSpeed(b) {
            b.dx = Math.min(Math.max(b.dx, -MAX_SPEED), MAX_SPEED);
            b.dy = Math.min(Math.max(b.dy, -MAX_SPEED), MAX_SPEED);

            if (Math.abs(b.dx) < MIN_SPEED) {
                b.dx = b.dx > 0 ? MIN_SPEED : -MIN_SPEED;
            }
            if (Math.abs(b.dy) < MIN_SPEED) {
                b.dy = b.dy > 0 ? MIN_SPEED : -MIN_SPEED;
            }
        }

        function getBallPower(b) {
            const speed = Math.hypot(b.dx, b.dy);
            return Math.max(1, Math.floor(speed - BASE_SPEED) + 1);
        }

        function hexToRgb(hex) {
            const h = hex.replace("#", "");
            return {
                r: parseInt(h.slice(0, 2), 16),
                g: parseInt(h.slice(2, 4), 16),
                b: parseInt(h.slice(4, 6), 16),
            };
        }

        function rgbToHex({ r, g, b }) {
            return (
                "#" +
                [r, g, b]
                    .map((v) => {
                        const h = v.toString(16);
                        return h.length === 1 ? "0" + h : h;
                    })
                    .join("")
            );
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function getPoweredColor(baseHex, b) {
            const base = hexToRgb(baseHex);
            const red = { r: 255, g: 80, b: 80 };
            const power = getBallPower(b);
            const t = Math.min(1, (power - 1) / 4); // saturate by power 5
            return rgbToHex({
                r: Math.round(lerp(base.r, red.r, t)),
                g: Math.round(lerp(base.g, red.g, t)),
                b: Math.round(lerp(base.b, red.b, t)),
            });
        }

        function moveBall(b, dtMs) {
            // progressively ramp speed from MIN_SPEED to MAX_SPEED over 60s of survival
            b.timeSinceLaunchMs += dtMs;
            const progress = Math.min(1, b.timeSinceLaunchMs / 60_000);
            const targetSpeed = MIN_SPEED + (MAX_SPEED - MIN_SPEED) * progress;

            let speed = Math.hypot(b.dx, b.dy);
            if (speed === 0) {
                // give a small nudge if somehow stopped
                b.dx = targetSpeed;
                b.dy = 0;
                speed = targetSpeed;
            }
            const scale = targetSpeed / speed;
            b.dx *= scale;
            b.dy *= scale;

            b.x += b.dx;
            b.y += b.dy;
        }

        function movePaddles() {
            if (keysDown.has("w")) paddles.day.y -= PADDLE_SPEED;
            if (keysDown.has("s")) paddles.day.y += PADDLE_SPEED;
            if (keysDown.has("ArrowUp")) paddles.night.y -= PADDLE_SPEED;
            if (keysDown.has("ArrowDown")) paddles.night.y += PADDLE_SPEED;

            paddles.day.y = Math.max(
                0,
                Math.min(canvas.height - paddles.day.height, paddles.day.y),
            );
            paddles.night.y = Math.max(
                0,
                Math.min(canvas.height - paddles.night.height, paddles.night.y),
            );
        }

        function checkMiss(b) {
            if (state !== GAME_STATE.PLAYING || b.cooldownMs > 0) return;
            if (b.x < -b.radius) {
                handleMiss("day", b);
            } else if (b.x > canvas.width + b.radius) {
                handleMiss("night", b);
            }
        }

        function handleMiss(player, ballRef) {
            if (state !== GAME_STATE.PLAYING) return;
            const startX =
                player === "day" ? canvas.width * 0.25 : canvas.width * 0.75;
            const direction = player === "day" ? 1 : -1;
            resetBall(ballRef, direction, ballRef.owner, startX, true);
        }

        function endGame(winnerKey) {
            state = GAME_STATE.GAME_OVER;
            overlay.classList.remove("hidden");
            overlay.textContent = `${
                winnerKey === "day" ? "Day" : "Night"
            } wins! Press Space to restart`;
        }

        function updateTimer(dtMs) {
            if (state === GAME_STATE.PLAYING) {
                remainingTimeMs = Math.max(0, remainingTimeMs - dtMs);
                if (remainingTimeMs === 0) {
                    const winnerKey =
                        dayScore === nightScore
                            ? "day"
                            : dayScore > nightScore
                              ? "day"
                              : "night";
                    endGame(winnerKey);
                }
            }
        }

        function updateHUD() {
            const dayPercent = Math.round((dayScore / totalSquares) * 100);
            const nightPercent = Math.round((nightScore / totalSquares) * 100);

            dayInfo.textContent = `Day ${dayPercent}%`;
            nightInfo.textContent = `Night ${nightPercent}%`;

            const minutes = Math.floor(remainingTimeMs / 60000);
            const seconds = Math.floor((remainingTimeMs % 60000) / 1000)
                .toString()
                .padStart(2, "0");
            timerEl.textContent = `${minutes}:${seconds}`;
        }

        function checkTerritoryWin() {
            if (state === GAME_STATE.GAME_OVER) return;
            if (dayScore / totalSquares >= WIN_PERCENT) {
                endGame("day");
            } else if (nightScore / totalSquares >= WIN_PERCENT) {
                endGame("night");
            }
        }

        function gameLoop() {
            const now = performance.now();
            const dtMs = now - lastTimestamp;
            lastTimestamp = now;

            // Ensure main overlay only shows for idle/game-over
            if (state === GAME_STATE.PLAYING) {
                overlay.classList.add("hidden");
            } else {
                overlay.classList.remove("hidden");
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawSquares();

            if (
                state === GAME_STATE.PLAYING ||
                state === GAME_STATE.COUNTDOWN
            ) {
                movePaddles();
            }

            if (state === GAME_STATE.PLAYING) {
                balls.forEach((b) => {
                    if (b.cooldownMs > 0) {
                        b.cooldownMs -= dtMs;
                        if (b.cooldownMs <= 0) {
                            const dir = b.owner === "DAY" ? 1 : -1;
                            launchBall(b, dir);
                            b.cooldownMs = 0;
                        }
                    } else {
                        moveBall(b, dtMs);
                        checkWallCollision(b);
                        checkPaddleCollision(b);
                        checkSquareCollisionAndPaint(b);
                        checkMiss(b);
                    }
                });
            }

            updateTimer(dtMs);
            checkTerritoryWin();

            drawPaddles();
            if (state !== GAME_STATE.IDLE) {
                balls.forEach((b) => drawBall(b));
            }

            updateHUD();

            updateSideCountdowns();

            requestAnimationFrame(gameLoop);
        }

        // Initialize idle screen
        overlay.classList.remove("hidden");
        overlay.textContent = "Tap to Start (or press Space)";
        requestAnimationFrame(gameLoop);

        function updateSideCountdowns() {
            const dayBall = balls[0];
            const nightBall = balls[1];

            if (state === GAME_STATE.PLAYING) {
                if (dayBall.cooldownMs > 0) {
                    overlayLeft.classList.remove("hidden");
                    overlayLeft.textContent = Math.ceil(
                        dayBall.cooldownMs / 1000,
                    );
                } else {
                    overlayLeft.classList.add("hidden");
                }

                if (nightBall.cooldownMs > 0) {
                    overlayRight.classList.remove("hidden");
                    overlayRight.textContent = Math.ceil(
                        nightBall.cooldownMs / 1000,
                    );
                } else {
                    overlayRight.classList.add("hidden");
                }
            } else {
                overlayLeft.classList.add("hidden");
                overlayRight.classList.add("hidden");
            }
        }
    </script>
</html>
